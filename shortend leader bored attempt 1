/**
 * Calculates the bucket range for a given score.
 * @param {number} value The new score.
 * @param {number} min The min of the previous range.
 * @param {number} max The max of the previous range. Must be greater than min.
 * @return {Object<string, number>} Returns an object containing the new min and max.
 */
function bucket(value, min, max) {
    const bucketSize = (max - min) / 3;
    const bucketMin = Math.floor(value / bucketSize) * bucketSize;
    const bucketMax = bucketMin + bucketSize;
    return { min: bucketMin, max: bucketMax };
  }
  
  export default bucket;

 /**
 * Recursively writes the score to the correct collection.
 * @param {number} id The user associated with the score.
 * @param {number} value The new score.
 * @param {admin.firestore.CollectionReference} coll The collection this value should be written to.
 * @param {Object<string, number>} range An object with properties min and max defining the range this score should be in.
 * @param {admin.firestore.Transaction} transaction The transaction used to ensure consistency during tree updates.
 * @param {Array<PendingWrite>} pendingWrites A series of writes that should occur once all reads within a transaction have completed.
 * @return {void} Write error/success is handled via the transaction object.
 */
async function writeScoreToCollection(id, value, coll, range, transaction, pendingWrites) {
    const snapshot = await transaction.get(coll);
    if (snapshot.empty) {
      // This is the first score to be inserted into this node.
      for (const write of pendingWrites) {
        write(transaction);
      }
      const docRef = coll.doc();
      transaction.create(docRef, { exact: { score: value, user: id } });
      return;
    }
  
    const min = range.min;
    const max = range.max;
  
    for (const node of snapshot.docs) {
      const data = node.data();
      if (data.exact !== undefined) {
        // This node held an exact score.
        const newRange = bucket(value, min, max);
        const tempRange = bucket(data.exact.score, min, max);
  
        if (newRange.min === tempRange.min && newRange.max === tempRange.max) {
          // The scores belong in the same range, so we need to "demote" both to a lower level of the tree and convert this node to a range.
          const rangeData = {
            range: newRange,
            count: 2,
          };
          for (const write of pendingWrites) {
            write(transaction);
          }
          const docReference = node.ref;
          transaction.set(docReference, rangeData);
          transaction.create(docReference.collection("scores").doc(), data);
          transaction.create(
            docReference.collection("scores").doc(),
            { exact: { score: value, user: id } },
          );
          return;
        } else {
          // The scores are in different ranges. Continue and try to find a range that fits this score.
          continue;
        }
      }
  
      if (data.range.min <= value && data.range.max > value) {
        // The score belongs to this range that may have subvalues.
        // Increment the range's count in pendingWrites, since subsequent recursion may incur more reads.
        const docReference = node.ref;
        const newCount = node.get("count") + 1;
        pendingWrites.push((t) => {
          t.update(docReference, { count: newCount });
        });
        const newRange = bucket(value, min, max);
        return writeScoreToCollection(
          id,
          value,
          docReference.collection("scores"),
          newRange,
          transaction,
          pendingWrites,
        );
      }
    }
  
    // No appropriate range was found, create an `exact` value.
    transaction.create(coll.doc(), { exact: { score: value, user: id } });
  }
  
  export default writeScoreToCollection; 

  /**
 * Updates the count of players in a range.
 * @param {admin.firestore.DocumentReference} docReference The document reference to update.
 * @param {number} newCount The new count of players in the range.
 * @return {Function} A function that updates the count when called with a transaction.
 */
function updateCount(docReference, newCount) {
    return (t) => {
      t.update(docReference, { count: newCount });
    };
  }
  
  export default updateCount;

  /**
 * Creates a new score in the leaderboard.
 * @param {number} playerID The ID of the player.
 * @param {number} score The new score.
 * @param {admin.firestore
