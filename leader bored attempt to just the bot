/**
 * Calculates the bucket range for a given score.
 * @param {number} value The new score.
 * @param {number} min The min of the previous range.
 * @param {number} max The max of the previous range. Must be greater than min.
 * @return {Object<string, number>} Returns an object containing the new min and max.
 */
function bucket(value, min, max) {
    const bucketSize = Math.floor((max - min) / 3); // Use Math.floor to avoid floating-point precision issues
    const bucketMin = Math.floor(value / bucketSize) * bucketSize;
    const bucketMax = bucketMin + bucketSize;
    return { min: bucketMin, max: bucketMax };
  }
  
  export default bucket;


  /**
 * Recursively writes the score to the correct collection.
 * @param {number} id The user associated with the score.
 * @param {number} value The new score.
 * @param {admin.firestore.CollectionReference} coll The collection this value should be written to.
 * @param {Object<string, number>} range An object with properties min and max defining the range this score should be in.
 * @param {admin.firestore.Transaction} transaction The transaction used to ensure consistency during tree updates.
 * @return {Promise<void>} Resolves when the write is complete.
 */
async function writeScoreToCollection(id, value, coll, range, transaction) {
    const snapshot = await transaction.get(coll);
    if (snapshot.empty) {
      // This is the first score to be inserted into this node.
      const docRef = coll.doc();
      transaction.create(docRef, { exact: { score: value, user: id } });
      return;
    }
  
    const min = range.min;
    const max = range.max;
  
    for (const node of snapshot.docs) {
      const data = node.data();
      if (data.exact !== undefined) {
        // This node held an exact score.
        const newRange = bucket(value, min, max);
        const tempRange = bucket(data.exact.score, min, max);
  
        if (newRange.min === tempRange.min && newRange.max === tempRange.max) {
          // The scores belong in the same range, so we need to "demote" both to a lower level of the tree and convert this node to a range.
          const rangeData = {
            range: newRange,
            count: 2,
          };
          const docReference = node.ref;
          transaction.set(docReference, rangeData);
          transaction.create(docReference.collection("scores").doc(), data);
          transaction.create(
            docReference.collection("scores").doc(),
            { exact: { score: value, user: id } },
          );
          return;
        } else {
          // The scores are in different ranges. Continue and try to find a range that fits this score.
          continue;
        }
      }
  
      if (data.range.min <= value && data.range.max > value) {
        // The score belongs to this range that may have subvalues.
        // Increment the range's count.
        const docReference = node.ref;
        const newCount = node.get("count") + 1;
        transaction.update(docReference, { count: newCount });
        const newRange = bucket(value, min, max);
        return writeScoreToCollection(
          id,
          value,
          docReference.collection("scores"),
          newRange,
          transaction,
        );
      }
    }
  
    // No appropriate range was found, create an `exact` value.
    transaction.create(coll.doc(), { exact: { score: value, user: id } });
  }
  
  export default writeScoreToCollection;


  /**
 * Creates a new score in the leaderboard.
 * @param {number} playerID The ID of the player.
 * @param {number} score The new score.
 * @param {admin.firestore.Firestore} db The Firestore instance.
 * @return {Promise<void>} Resolves when the score is created.
 */
async function createScore(playerID, score, db) {
    const transaction = db.transaction();
    try {
      const coll = db.collection("leaderboard");
      const range = { min: 0, max: 100 }; // Replace with the actual range for your leaderboard
      await writeScoreToCollection(playerID, score, coll, range, transaction);
      await transaction.commit();
    } catch (error) {
      await transaction.rollback();
      throw error;
    }
  }
  
  export default createScore;
